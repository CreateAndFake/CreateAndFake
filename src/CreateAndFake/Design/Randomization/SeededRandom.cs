using System;

namespace CreateAndFake.Design.Randomization
{
    /// <summary>For generating deterministic random values.</summary>
    public sealed class SeededRandom : ValueRandom
    {
        /// <summary>Lock to prevent thread collision with seeds.</summary>
        private readonly object m_Lock = new object();

        /// <summary>Current seed to be used for the next randomized value.</summary>
        private int m_Seed;

        /// <summary>Current seed to be used for the next randomized value.</summary>
        public int Seed
        {
            get { lock (m_Lock) { return m_Seed; } }
        }

        /// <summary>Initial seed used by the instance.</summary>
        public int InitialSeed { get; }

        /// <summary>Sets up the randomizer with the given seed.</summary>
        /// <param name="seed">Current seed to be used for the next randomized value.</param>
        public SeededRandom(int? seed = null) : this(true, seed) { }

        /// <summary>Sets up the randomizer with the given seed.</summary>
        /// <param name="onlyValidValues">Option to prevent generating invalid values.</param>
        /// <param name="seed">Current seed to be used for the next randomized value.</param>
        public SeededRandom(bool onlyValidValues, int? seed = null) : base(onlyValidValues)
        {
            InitialSeed = seed ?? Environment.TickCount;
            m_Seed = InitialSeed;
        }

        /// <summary>Generates a byte array filled with random bytes.</summary>
        /// <param name="length">Length of the array to generate.</param>
        /// <returns>The generated byte array.</returns>
        protected override byte[] NextBytes(short length)
        {
            Random gen;
            lock (m_Lock)
            {
                gen = new Random(m_Seed);
                m_Seed = gen.Next();
            }

            byte[] buffer = new byte[length];
            gen.NextBytes(buffer);
            return buffer;
        }
    }
}
